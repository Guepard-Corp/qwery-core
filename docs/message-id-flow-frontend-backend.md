# Message ID flow: frontend vs backend (streaming + save)

Exact flow of message IDs from UI through streaming to save and load.

---

## Policy: we do not use the frontend ID for persistence

- **Backend is the single source of truth for message IDs.** The persisted row `id` is always generated by the backend (`MessageEntity.create()` → `generateIdentity()`).
- We **do not** pass `message.id` from the frontend or stream into `CreateMessageInput` or `MessageEntity.create()`.
- `CreateMessageInput` has no `id` field; the entity always creates a new UUID. Frontend/stream IDs are only used for idempotency (skip if UUID already exists) and are stored inside `content.id` for reference only.

---

## 1. ID sources

| Phase | Who generates | Format | Where used |
|-------|----------------|--------|------------|
| **User message (client)** | `useChat` (AI SDK) | Client-generated (e.g. nanoid), **not necessarily UUID** | `UIMessage.id` in browser |
| **Assistant message (stream)** | Backend stream | `uuidv4()` in `toUIMessageStreamResponse({ generateMessageId: () => uuidv4() })` | Sent in stream; client uses as `UIMessage.id` for assistant message |
| **Saved row (backend)** | `MessageEntity.create()` | `generateIdentity()` → `uuidv4()` | DB/file primary key; **never** the frontend or stream ID |

So there are up to **three** different IDs for the same logical message:

- **Frontend ID** (user msg: AI SDK; assistant msg: from stream)
- **Stream ID** (assistant only; same as what client sees during/after stream if stream sends id)
- **Backend ID** (only after save; from `MessageEntity.create()`)

---

## 2. Flow (step by step)

```mermaid
sequenceDiagram
  participant User
  participant useChat as useChat (AI SDK)
  participant Stream as Backend stream
  participant Persist as MessagePersistenceService
  participant Create as CreateMessageService
  participant DB as MessageRepository / storage
  participant Load as GetMessages / convertMessages

  Note over User,Load: Send user message
  User->>useChat: sendMessage({ text })
  useChat->>useChat: Add user UIMessage (id = clientId, e.g. nanoid)
  useChat->>Stream: POST /stream (messages with client ids)

  Note over User,Load: Stream assistant reply
  Stream->>Stream: generateMessageId() => uuidv4()  (streamMsgId)
  Stream->>useChat: SSE chunks (message id = streamMsgId)
  useChat->>useChat: Assistant UIMessage (id = streamMsgId)

  Note over User,Load: Save (onFinish)
  Stream->>Persist: persistMessages(finishedMessages)  [UIMessage.id = clientId / streamMsgId]
  loop Each message
    Persist->>Persist: isUUID(msg.id)? findById(msg.id)
    alt id is UUID and exists
      Persist->>Persist: skip (idempotency)
    else create new
      Persist->>Create: execute({ input: content, role, createdBy }, conversationSlug)
      Create->>Create: MessageEntity.create()  => newId = uuidv4()
      Create->>DB: create({ id: newId, conversationId, content: { id: msg.id, parts, role } })
    end
  end

  Note over User,Load: Load (later or after refresh)
  User/Load->>Load: useGetMessagesByConversationSlug()
  Load->>DB: findByConversationId(conversationId)
  DB->>Load: Message[] (each id = newId, content.id = original frontend/stream id)
  Load->>useChat: convertMessages(MessageOutput[]) => UIMessage[] with id = message.id (backend newId)
```

---

## 3. Where each ID lives

- **Frontend (before any load)**  
  - `messages[i].id` = client-generated (user) or stream-generated UUID (assistant).  
  - No backend row id yet for new messages.

- **During persist**  
  - Input to `persistMessages`: `UIMessage[]` with those frontend/stream ids.  
  - Backend **never** uses that value as the row primary key.  
  - `CreateMessageService` always calls `MessageEntity.create()` → new UUID.  
  - Stored row: `id` = that new UUID; `content` = serialized UIMessage (so `content.id` = frontend/stream id).

- **After load**  
  - API returns `MessageOutput[]` with `id` = row id (backend UUID).  
  - `convertMessages(messages)` builds `UIMessage[]` with `id: message.id` (backend id).  
  - So after load, **frontend and backend IDs are the same** (backend id wins).  
  - Feedback uses `messageId` = that backend id.

---

## 4. Important code spots

| What | Where |
|------|--------|
| User message id | AI SDK `useChat` (client). Not set by our code. |
| Assistant message id in stream | `packages/agent-factory-sdk/src/agents/agent-session.ts`: `toUIMessageStreamResponse({ generateMessageId: () => uuidv4() })` |
| Idempotency check (reuse by id) | `MessagePersistenceService.persistMessages`: only if `isUUID(message.id)` and `findById(message.id)` returns existing → skip |
| New row id (always new) | `MessageEntity.create()` in `packages/domain/src/entities/ai/message.type.ts` → `generateIdentity()` → `uuidv4()` |
| Create use case ignores input id | `CreateMessageService.execute`: input has no `id`; entity id is always from `MessageEntity.create()` |
| Load: backend id becomes UI id | `convertMessages` in `apps/web/lib/utils/messages-converter.ts`: `id: message.id` (MessageOutput.id = backend row id) |
| Feedback | `handleSubmitFeedback(messageId, …)` → backend expects `messageId` = **backend** id (so correct after load; during streaming, if UI still has stream id, feedback can fail until messages are reloaded) |

---

## 5. Summary

- **Frontend id**: user = client (AI SDK), assistant = from stream (`uuidv4()` on backend).  
- **Backend (saved) id**: always a **new** UUID from `MessageEntity.create()`; frontend/stream id is **not** used as row id.  
- **Streaming**: same as above; stream sends one UUID for the assistant message; save still creates a different row UUID.  
- **Save**: `persistMessages` sends frontend/stream ids; backend only uses them for idempotency (if UUID and already exists) and stores them in `content.id`.  
- **Load**: UI replaces with backend id via `convertMessages(MessageOutput[])` → `id: message.id`.  
- So: **diff between frontend and backend id** = frontend/stream id vs row id; they only match after load because we overwrite with `message.id` (backend). Feedback and any API that key off message must use **backend id** (the one in `MessageOutput.id` / after load).

---

## 6. Feedback when we do not use frontend ID

Because we never use the frontend/stream ID as the row id, the UI only has the **backend** id after messages are loaded from the server (e.g. after refresh or after a refetch). So:

- **After load/refetch**: `message.id` is the backend id → feedback works.
- **During/right after streaming**: `message.id` is still the stream id → `POST /feedback` with that id returns 404 (no row with that id).

**Ways to get feedback working without using frontend id:**

1. **Refetch messages when the stream ends**  
   When chat status goes from streaming to ready, invalidate (or refetch) the messages query for that conversation. The list then gets backend ids and feedback works. No change to backend or to “who owns the id”.

2. **Stream back the backend message id**  
   After persist in `onFinish`, send a custom SSE event or trailing payload with the new backend message id for the assistant message. The frontend updates that message’s `id` in state. Backend still generates the id; we only sync it to the client so feedback can use it.

3. **Disable or delay feedback until saved**  
   Show the feedback button as disabled (or “Saving…”) until the messages query has been refetched after the stream ends, so the UI is using backend ids.
